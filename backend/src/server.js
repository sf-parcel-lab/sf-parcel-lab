require('dotenv').config();
const express = require('express');
const app = express();
const cors = require('cors');
const { ChatOpenAI } = require('@langchain/openai');
const { HumanMessage, SystemMessage } = require('@langchain/core/messages');
const { MongoClient } = require('mongodb');
const agentRouter = require('./agent/agent_endpoint');

app.use(cors({ origin: 'http://localhost:3000' }));
app.use(express.json());

// LLM Setup
const SYSTEM_PROMPT = `
You are a helpful assistant for a San Francisco city parcel explorer.

Your job is to extract **structured MongoDB query filters** from user input.
The user will ask natural-language questions about land parcels in San Francisco.

IMPORTANT: Output ONLY a valid JSON object with MongoDB query filters. No extra text or explanations.

Available fields in the database:
- zoning_code: Zoning classification (e.g., "RH-1", "RH-2", "RM-1", "C-1", "M-1")
- planning_district: Planning district name (e.g., "Outer Sunset", "South of Market", "Mission")
- analysis_neighborhood: Neighborhood name (e.g., "Sunset/Parkside")
- police_district: Police district name (e.g., "TARAVAL")
- supervisor_district: Supervisor district number (e.g., "4")
- active: Boolean indicating if property is active (true/false)
- in_asr_secured_roll: Boolean indicating if property is in secured roll (true/false)

Query mapping rules:
- "residential" → {"zoning_code": {"$regex": "^RH|^RM", "$options": "i"}}
- "commercial" → {"zoning_code": {"$regex": "^C", "$options": "i"}}
- "mixed use" → {"zoning_code": {"$regex": "^M", "$options": "i"}}
- "two-family home" → {"zoning_code": "RH-2"}
- "Ingleside" → {"planning_district": "Ingleside"}
- "South of Market" → {"planning_district": "South of Market"}
- "Mission" → {"planning_district": "Mission"}
- "Sunset" → {"planning_district": {"$regex": "Sunset", "$options": "i"}}
- "active properties" → {"active": true}
- "inactive properties" → {"active": false}
- "secured roll" → {"in_asr_secured_roll": true}

Examples:
- "Show me residential properties" → {"zoning_code": {"$regex": "^RH|^RM", "$options": "i"}}
- "Find properties in Sunset" → {"planning_district": {"$regex": "Sunset", "$options": "i"}}
- "Commercial properties in South of Market" → {"zoning_code": {"$regex": "^C", "$options": "i"}, "planning_district": "South of Market"}
- "Active properties" → {"active": true}
- "Active residential properties" → {"zoning_code": {"$regex": "^RH|^RM", "$options": "i"}, "active": true}

Output ONLY the JSON object, no other text.
`;

const llm = new ChatOpenAI({
  modelName: "gpt-3.5-turbo",
  temperature: 0,
  openAIApiKey: process.env.OPENAI_API_KEY
});

// MongoDB Connection
const client = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017');
const db = client.db('sf_parcels');
const collection = db.collection('parcels_merged');

app.get('/', (req, res) => {
  res.send('SF Parcel Backend API');
});

// Agent routes
app.use('/api', agentRouter);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Debug endpoint to check database structure
app.get('/api/debug/fields', async (req, res) => {
  try {
    const sample = await collection.findOne({});
    if (sample) {
      const fields = Object.keys(sample);
      res.json({
        total_parcels: await collection.countDocuments(),
        sample_fields: fields,
        sample_data: sample
      });
    } else {
      res.json({ error: 'No data found in collection' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// LLM Chatbot Query endpoint
app.post('/api/query', async (req, res) => {
  try {
    const { message } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    console.log('Processing query:', message);

    // Generate MongoDB query using LLM
    const messages = [
      new SystemMessage(SYSTEM_PROMPT),
      new HumanMessage(message)
    ];
    
    const response = await llm.invoke(messages);
    console.log('LLM Response:', response.content);
    
    let mongoQuery;
    try {
      mongoQuery = JSON.parse(response.content);
    } catch (parseError) {
      console.error('Failed to parse LLM response as JSON:', response.content);
      return res.status(500).json({ 
        error: 'Invalid query format generated by AI',
        details: 'The AI generated an invalid JSON response'
      });
    }
    
    console.log('Generated MongoDB query:', JSON.stringify(mongoQuery, null, 2));
    
    // Execute MongoDB query
    const results = await collection.find(mongoQuery, { projection: { _id: 0 } }).limit(200).toArray();
    console.log(`Found ${results.length} parcels matching query`);
    
    // Debug: Check geometry data
    if (results.length > 0) {
      const sampleParcel = results[0];
      console.log('Sample parcel shape field:', sampleParcel.shape ? 'EXISTS' : 'MISSING');
      console.log('Sample parcel geometry field:', sampleParcel.geometry ? 'EXISTS' : 'MISSING');
      if (sampleParcel.shape) {
        console.log('Shape type:', sampleParcel.shape.type);
        console.log('Shape coordinates length:', sampleParcel.shape.coordinates ? sampleParcel.shape.coordinates.length : 'NONE');
      }
    }
    
    res.json({
      data: results,
      query_used: mongoQuery,
      message: message
    });
    
  } catch (error) {
    console.error('Query error:', error);
    res.status(500).json({ 
      error: 'Query failed', 
      details: error.message 
    });
  }
});

// Route API pour exposer les parcelles
app.get('/api/parcels', async (req, res) => {
  try {
    const parcels = await collection.find({}).toArray();
    console.log('Nombre de parcelles retournées :', parcels.length);

    // Convertir les parcelles en format GeoJSON FeatureCollection
    const geojsonFeatures = parcels.map(parcel => ({
      type: 'Feature',
      geometry: parcel.shape || parcel.geometry || null,
      properties: {
        // Inclure toutes les propriétés sauf les champs géométriques
        ...Object.fromEntries(
          Object.entries(parcel).filter(([key]) => 
            !['shape', 'geometry', 'the_geom'].includes(key)
          )
        )
      }
    }));

    const geojsonResponse = {
      type: 'FeatureCollection',
      features: geojsonFeatures
    };

    res.json(geojsonResponse);
  } catch (err) {
    res.status(500).json({ error: err.toString() });
  }
});

const PORT = process.env.PORT || 3001;

// Initialize MongoDB connection
async function startServer() {
  try {
    await client.connect();
    console.log('Connected to MongoDB');
    
    app.listen(PORT, () => {
      console.log(`API server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to connect to MongoDB:', error);
    process.exit(1);
  }
}

startServer();
